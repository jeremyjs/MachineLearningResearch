function [ bic, newpar ] = BIC( x,t,operation,parameters )
    delta = 0.0001;
    variance=10;
    
    operation
    newpar=parameters;
    iteration=1;
    while iteration<1000 %absolute cutoff on number of iterations of 1000
        gradient=zeros(size(newpar));
        baseline = logmultigauss(t,gramcov(x,x,operation,newpar,variance));    
        for i=1:numel(newpar)
            if isnan(newpar(i))
                gradient(i)=0;
            else
                newpar(i)=newpar(i)+delta;
                gradient(i) = (logmultigauss(t,gramcov(x,x,operation,newpar,variance)) - baseline)/delta;
                newpar(i)=newpar(i)-delta;
            end
        end
        vargrad= (logmultigauss(t,gramcov(x,x,operation,newpar,variance+delta)) - baseline)/delta;
        
        if sum( gradient(~isnan(gradient)).^2 +vargrad.^2)==0 %if gradient is zero, break
            break
        end

        if iteration~=1
            beta = sum( gradient(~isnan(gradient)).^2 + vargrad.^2) / sum( prevgrad(~isnan(prevgrad)).^2 +prevvargrad.^2);
            S = gradient + beta*prevS; %defined in wikipedia article on conjugate gradients
            varS = vargrad + beta*prevvarS;
        else
            S = gradient;
            varS = vargrad;
        end

        
        %search for positive derivative
        Smag = sqrt(sum( S(~isnan(S)).^2 ) + varS.^2);
        if Smag==0
            break
        end
        Sunit = S / Smag; %normalize S to make optimization less complicated
        upper=10*delta;
        lower=0;
        
        %increase upper exponentially until derivative is negative
        while logmultigauss(t,gramcov(x,x,operation,newpar+(upper+delta)*Sunit,variance))-logmultigauss(t,gramcov(x,x,operation,newpar+upper*Sunit,variance))>0
            upper=upper*10;
        end
        
        %use bisection method to find when derivative is 0
        med = upper/2;
        while upper-lower>delta            
            if logmultigauss(t,gramcov(x,x,operation,newpar+(med+delta)*Sunit,variance))-logmultigauss(t,gramcov(x,x,operation,newpar+med*Sunit,variance))>0
                lower = med;
            else
                upper = med;
            end
            
            med = (upper + lower)/2;
        end
        
        newpar = newpar + med*Sunit;
        
        %stop iterating if change in newpar is sufficiently small
        if sqrt(sum( (med*Sunit).^2 ))<delta*10
            break
        end
        
        prevgrad = gradient;
        prevS = S;
        iteration=iteration+1;
        
    end
    logML = logmultigauss(t,gramcov(x,x,operation,newpar,variance)); %maximum likelihood
    bic = -2* logML + sum(~isnan(parameters(:)))*log(length(x)); 
    
    

end

